<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.7" xml:lang="en-US">
  <compounddef id="structm0st4fa_1_1lexana_1_1_token" kind="struct" language="C++" prot="public">
    <compoundname>m0st4fa::lexana::Token</compoundname>
    <includes refid="_l_a_data_structs_8h" local="no">LADataStructs.h</includes>
    <templateparamlist>
      <param>
        <type>typename TerminalT</type>
      </param>
      <param>
        <type>typename AttrT</type>
        <defval>std::string_view</defval>
      </param>
    </templateparamlist>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structm0st4fa_1_1lexana_1_1_token_1ad038bc29e309a10268a05d9d0a274cb0" prot="public" static="no" mutable="no">
        <type>TerminalT</type>
        <definition>TerminalT m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::name</definition>
        <argsstring></argsstring>
        <name>name</name>
        <qualifiedname>m0st4fa::lexana::Token::name</qualifiedname>
        <initializer>= TerminalT::T_EOF</initializer>
        <briefdescription>
<para>The name associated with the token. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="41" column="11" bodyfile="include/lexana/LADataStructs.h" bodystart="41" bodyend="-1"/>
        <referencedby refid="structm0st4fa_1_1lexana_1_1_token_1a1cb9aab109d53f9e5dd898dc8cea5f3a" compoundref="_l_a_data_structs_8h" startline="61" endline="63">m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::operator==</referencedby>
      </memberdef>
      <memberdef kind="variable" id="structm0st4fa_1_1lexana_1_1_token_1a79643c2239a700748387923a29bcd3f5" prot="public" static="no" mutable="no">
        <type>AttrT</type>
        <definition>AttrT m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::attribute</definition>
        <argsstring></argsstring>
        <name>attribute</name>
        <qualifiedname>m0st4fa::lexana::Token::attribute</qualifiedname>
        <briefdescription>
<para>The attribute associated with the token. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="45" column="7" bodyfile="include/lexana/LADataStructs.h" bodystart="45" bodyend="-1"/>
        <referencedby refid="structm0st4fa_1_1lexana_1_1_token_1a1cb9aab109d53f9e5dd898dc8cea5f3a" compoundref="_l_a_data_structs_8h" startline="61" endline="63">m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::operator==</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="structm0st4fa_1_1lexana_1_1_token_1a45437adb5499adcbd7c98653bba277b5" prot="public" static="yes" mutable="no">
        <type>const <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref>&lt; TerminalT, AttrT &gt;</type>
        <definition>const Token&lt; TerminalT, AttrT &gt; m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::EPSILON</definition>
        <argsstring></argsstring>
        <name>EPSILON</name>
        <qualifiedname>m0st4fa::lexana::Token::EPSILON</qualifiedname>
    <requiresclause>requires (TerminalT a) { TerminalT::T_EOF; TerminalT::T_EPSILON; stringfy(a); }    </requiresclause>
        <initializer>= { TerminalT::T_EPSILON }</initializer>
        <briefdescription>
<para>The <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> object representing epsilon (an empty-string lexeme). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="50" column="20" bodyfile="include/lexana/LADataStructs.h" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structm0st4fa_1_1lexana_1_1_token_1ac16458b3559cc69479bb176cdd7a5d03" prot="public" static="yes" mutable="no">
        <type>const <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref>&lt; TerminalT, AttrT &gt;</type>
        <definition>const Token&lt; TerminalT, AttrT &gt; m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::TEOF</definition>
        <argsstring></argsstring>
        <name>TEOF</name>
        <qualifiedname>m0st4fa::lexana::Token::TEOF</qualifiedname>
    <requiresclause>requires (TerminalT a) { TerminalT::T_EOF; TerminalT::T_EPSILON; stringfy(a); }    </requiresclause>
        <initializer>= { TerminalT::T_EOF }</initializer>
        <briefdescription>
<para>The <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> object representing an end-of-file lexeme. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="54" column="20" bodyfile="include/lexana/LADataStructs.h" bodystart="54" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structm0st4fa_1_1lexana_1_1_token_1a1cb9aab109d53f9e5dd898dc8cea5f3a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::operator==</definition>
        <argsstring>(const Token &amp;rhs) const</argsstring>
        <name>operator==</name>
        <qualifiedname>m0st4fa::lexana::Token::operator==</qualifiedname>
        <param>
          <type>const <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Checks whether to <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> objects are equal (i.e. have the same name <emphasis>and</emphasis> attribute). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The right-hand-side parameter/operand of the operator. The left-hand-side is <computeroutput>this</computeroutput> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if both <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> objects are equal; <computeroutput>false</computeroutput> otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="61" column="6" bodyfile="include/lexana/LADataStructs.h" bodystart="61" bodyend="63"/>
        <references refid="structm0st4fa_1_1lexana_1_1_token_1a79643c2239a700748387923a29bcd3f5" compoundref="_l_a_data_structs_8h" startline="45">m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::attribute</references>
        <references refid="structm0st4fa_1_1lexana_1_1_token_1ad038bc29e309a10268a05d9d0a274cb0" compoundref="_l_a_data_structs_8h" startline="41">m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::name</references>
      </memberdef>
      <memberdef kind="function" id="structm0st4fa_1_1lexana_1_1_token_1abb7384f7caeedf830638cb480da03764" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::operator std::string</definition>
        <argsstring>() const</argsstring>
        <name>operator std::string</name>
        <qualifiedname>m0st4fa::lexana::Token::string</qualifiedname>
        <briefdescription>
<para>Calls <ref refid="structm0st4fa_1_1lexana_1_1_token_1a03050543e301ace90c5bcb0363432832" kindref="member">toString()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="68" column="1" bodyfile="include/lexana/LADataStructs.h" bodystart="68" bodyend="70"/>
        <references refid="structm0st4fa_1_1lexana_1_1_token_1a03050543e301ace90c5bcb0363432832" compoundref="_l_a_data_structs_8h" startline="76" endline="78">m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::toString</references>
      </memberdef>
      <memberdef kind="function" id="structm0st4fa_1_1lexana_1_1_token_1a03050543e301ace90c5bcb0363432832" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::toString</definition>
        <argsstring>() const</argsstring>
        <name>toString</name>
        <qualifiedname>m0st4fa::lexana::Token::toString</qualifiedname>
        <briefdescription>
<para>Converts the <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> object into an std::string object and returns it. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The std::string object corresponding to <computeroutput>this</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/lexana/LADataStructs.h" line="76" column="13" bodyfile="include/lexana/LADataStructs.h" bodystart="76" bodyend="78"/>
        <referencedby refid="structm0st4fa_1_1lexana_1_1_token_1abb7384f7caeedf830638cb480da03764" compoundref="_l_a_data_structs_8h" startline="68" endline="70">m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;::operator std::string</referencedby>
        <referencedby refid="namespacem0st4fa_1_1lexana_1a5130a88f30b34e251b294ea69ecdae91" compoundref="_l_a_data_structs_8h" startline="96" endline="98">m0st4fa::lexana::operator&lt;&lt;</referencedby>
      </memberdef>
      </sectiondef>
    <requiresclause>requires (TerminalT a) { TerminalT::T_EOF; TerminalT::T_EPSILON; stringfy(a); }    </requiresclause>
    <briefdescription>
<para><ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> used by the lexical analyzer; each token has a name and an attribute and represents a lexeme from the input file. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="note"><para>The class can be written to <computeroutput>std::ostream</computeroutput> (it overloads <computeroutput>operator&lt;&lt;</computeroutput>). </para>
</simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>TerminalT</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the name of a <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> object. It is thought of as a type of terminals. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>AttrT</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the attribute of a <ref refid="structm0st4fa_1_1lexana_1_1_token" kindref="compound">Token</ref> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
    </detaileddescription>
    <collaborationgraph>
      <node id="2">
        <label>TerminalT</label>
      </node>
      <node id="1">
        <label>m0st4fa::lexana::Token&lt; TerminalT, AttrT &gt;</label>
        <link refid="structm0st4fa_1_1lexana_1_1_token"/>
        <childnode refid="2" relation="usage">
          <edgelabel>+name</edgelabel>
        </childnode>
        <childnode refid="3" relation="usage">
          <edgelabel>+attribute</edgelabel>
        </childnode>
        <childnode refid="5" relation="usage">
          <edgelabel>+EPSILON</edgelabel>
          <edgelabel>+TEOF</edgelabel>
        </childnode>
      </node>
      <node id="5">
        <label>static const Token&lt; TerminalT, std::string_view &gt;</label>
      </node>
      <node id="4">
        <label>std::basic_string_view&lt; Char &gt;</label>
      </node>
      <node id="3">
        <label>std::string_view</label>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="include/lexana/LADataStructs.h" line="36" column="1" bodyfile="include/lexana/LADataStructs.h" bodystart="36" bodyend="79"/>
    <listofallmembers>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1a79643c2239a700748387923a29bcd3f5" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>attribute</name></member>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1a45437adb5499adcbd7c98653bba277b5" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>EPSILON</name></member>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1ad038bc29e309a10268a05d9d0a274cb0" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>name</name></member>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1abb7384f7caeedf830638cb480da03764" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>operator std::string</name></member>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1a1cb9aab109d53f9e5dd898dc8cea5f3a" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>operator==</name></member>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1ac16458b3559cc69479bb176cdd7a5d03" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>TEOF</name></member>
      <member refid="structm0st4fa_1_1lexana_1_1_token_1a03050543e301ace90c5bcb0363432832" prot="public" virt="non-virtual"><scope>m0st4fa::lexana::Token</scope><name>toString</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
